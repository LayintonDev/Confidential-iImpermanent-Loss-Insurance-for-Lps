// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


import "./interfaces/IExecutionCallback.sol";
import "./interfaces/IImageArchive.sol";

/**
 * Abstract EigenCompute Receiver contract that implements IExecutionCallback
 * 
 * This contract combines service functions and callback handling in one abstract contract.
 * Users should extend this contract and override the abstract callback methods they need.
 * This contract automatically handles onExecutionResult and onExecutionError routing from EigenCompute.
 * 
 * Generated by EigenCompute on 2025-09-18T08:58:42.978Z
 * Functions: 5
 */
abstract contract ConfidentialInsuranceReceiver is IExecutionCallback {
    /// @notice Request data for EigenCompute execution
    struct ExecutionRequest {
        bytes32 configID;
        address callbackReceiver;
        string functionName;
        bytes encodedParams;
    }

    // The EigenCompute reservation ID
    uint256 public immutable reservationID;

    /**
     * Constructor to initialize the reservation ID
     * @param _reservationID The EigenCompute reservation ID
     */
    constructor(uint256 _reservationID) {
        reservationID = _reservationID;
    }

    /**
     * Modifier to ensure only EigenCompute can call callback functions
     */
    modifier onlyEigenCompute() {
        require(msg.sender == _getEigenCompute(), "Only EigenCompute can call this function");
        _;
    }

    /**
     * Implementation of IExecutionCallback.onExecutionResult
     * Automatically routes to typed callback methods
     * Can only be called by EigenCompute contract
     */
    function onExecutionResult(uint256 taskId, string memory functionName, bytes memory result) external override onlyEigenCompute {
        _handleExecutionCallback(taskId, functionName, result, "");
    }
    
    /**
     * Implementation of IExecutionCallback.onExecutionError  
     * Automatically routes to typed callback methods with error message
     * Can only be called by EigenCompute contract
     */
    function onExecutionError(uint256 taskId, string memory functionName, string memory error) external override onlyEigenCompute {
        _handleExecutionErrorCallback(taskId, functionName, error);
    }

    /**
     * Internal callback router for type-safe callbacks
     */
    function _handleExecutionCallback(
        uint256 taskId, 
        string memory functionName, 
        bytes memory result,
        string memory error
    ) internal {
        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_aggregateAttestations"))) {
            // Decode the execution result
            (uint256 result1, bool result2) = abi.decode(result, (uint256, bool));
            _onAggregateAttestations(taskId, result1, result2, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_calculateImpermanentLoss"))) {
            // Decode the execution result
            (uint256 result1, bool result2) = abi.decode(result, (uint256, bool));
            _onCalculateImpermanentLoss(taskId, result1, result2, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_calculatePayout"))) {
            // Decode the execution result
            uint256 resultValue = abi.decode(result, (uint256));
            _onCalculatePayout(taskId, resultValue, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_validateOraclePrices"))) {
            // Decode the execution result
            (bool result1, uint256[] memory result2) = abi.decode(result, (bool, uint256[]));
            _onValidateOraclePrices(taskId, result1, result2, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_verifyEncryptedAttestation"))) {
            // Decode the execution result
            (bool result1, uint256 result2) = abi.decode(result, (bool, uint256));
            _onVerifyEncryptedAttestation(taskId, result1, result2, error);
            return;
        }

        revert("Unknown function");
    }
    
    /**
     * Internal error callback router for type-safe error callbacks
     */
    function _handleExecutionErrorCallback(
        uint256 taskId, 
        string memory functionName, 
        string memory error
    ) internal {
        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_aggregateAttestations"))) {
            _onAggregateAttestations(taskId, 0, false, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_calculateImpermanentLoss"))) {
            _onCalculateImpermanentLoss(taskId, 0, false, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_calculatePayout"))) {
            _onCalculatePayout(taskId, 0, error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_validateOraclePrices"))) {
            _onValidateOraclePrices(taskId, false, new uint256[](0), error);
            return;
        }

        if (keccak256(bytes(functionName)) == keccak256(bytes("compute_verifyEncryptedAttestation"))) {
            _onVerifyEncryptedAttestation(taskId, false, 0, error);
            return;
        }

        revert("Unknown function");
    }

    /**
     * Get the EigenCompute contract address
     * @return address EigenCompute contract address
     * @dev This function reverts if EigenCompute is not deployed on this chain
     */
    function _getEigenCompute() internal view virtual returns (address) {
        _checkDeployed();
        return address(0xb1bc0253B3823f5f9fDC9DF04FcF8aDB8d2855E2);
    }

    /**
     * Get the EigenCompute ImageArchive contract
     * @return IImageArchive EigenCompute ImageArchive contract
     * @dev This function reverts if EigenCompute is not deployed on this chain
     */
    function _getImageArchive() internal view virtual returns (IImageArchive) {
        _checkDeployed();
        return IImageArchive(address(0x55FF811ab4972F4B6794731F66825C99618D9232));
    }

    /**
     * Check if EigenCompute is deployed on this chain
     * @dev This function reverts if EigenCompute is not deployed on this chain
     */
    function _checkDeployed() internal view virtual {
        require(block.chainid == 84532, "EigenCompute not deployed on this chain");
    }

    // ================== SERVICE FUNCTIONS ==================

    /**
     * Call aggregateAttestations with callback (internal async version)
     * Function aggregateAttestations from IConfidentialInsuranceSpec
     * The calling contract (address(this)) will receive the callback.
     * @param attestations Parameter of type uint256[]
     * @param signatures Parameter of type bytes[]
     * @param operatorPublicKeys Parameter of type bytes[]
     * @param threshold Parameter of type uint256
     * @return taskId Unique identifier for tracking this task
     */
    function _aggregateAttestationsAsync(uint256[] calldata attestations, bytes[] calldata signatures, bytes[] calldata operatorPublicKeys, uint256 threshold) internal returns (uint256 taskId) {        
        bytes memory encodedParams = abi.encode(attestations, signatures, operatorPublicKeys, threshold);
        
        return _submitTaskWithCallback(
            "compute_aggregateAttestations", 
            encodedParams,
            address(this)
        );
    }

    /**
     * Call calculateImpermanentLoss with callback (internal async version)
     * Function calculateImpermanentLoss from IConfidentialInsuranceSpec
     * The calling contract (address(this)) will receive the callback.
     * @param initialTokenAAmount Parameter of type uint256
     * @param initialTokenBAmount Parameter of type uint256
     * @param currentTokenAPrice Parameter of type uint256
     * @param currentTokenBPrice Parameter of type uint256
     * @param initialTokenAPrice Parameter of type uint256
     * @param initialTokenBPrice Parameter of type uint256
     * @param poolFeeRate Parameter of type uint256
     * @return taskId Unique identifier for tracking this task
     */
    function _calculateImpermanentLossAsync(uint256 initialTokenAAmount, uint256 initialTokenBAmount, uint256 currentTokenAPrice, uint256 currentTokenBPrice, uint256 initialTokenAPrice, uint256 initialTokenBPrice, uint256 poolFeeRate) internal returns (uint256 taskId) {        
        bytes memory encodedParams = abi.encode(initialTokenAAmount, initialTokenBAmount, currentTokenAPrice, currentTokenBPrice, initialTokenAPrice, initialTokenBPrice, poolFeeRate);
        
        return _submitTaskWithCallback(
            "compute_calculateImpermanentLoss", 
            encodedParams,
            address(this)
        );
    }

    /**
     * Call calculatePayout with callback (internal async version)
     * Function calculatePayout from IConfidentialInsuranceSpec
     * The calling contract (address(this)) will receive the callback.
     * @param policyId Parameter of type uint256
     * @param impermanentLoss Parameter of type uint256
     * @param coverageAmount Parameter of type uint256
     * @param deductible Parameter of type uint256
     * @param coverageRatio Parameter of type uint256
     * @return taskId Unique identifier for tracking this task
     */
    function _calculatePayoutAsync(uint256 policyId, uint256 impermanentLoss, uint256 coverageAmount, uint256 deductible, uint256 coverageRatio) internal returns (uint256 taskId) {        
        bytes memory encodedParams = abi.encode(policyId, impermanentLoss, coverageAmount, deductible, coverageRatio);
        
        return _submitTaskWithCallback(
            "compute_calculatePayout", 
            encodedParams,
            address(this)
        );
    }

    /**
     * Call validateOraclePrices with callback (internal async version)
     * Function validateOraclePrices from IConfidentialInsuranceSpec
     * The calling contract (address(this)) will receive the callback.
     * @param priceData Parameter of type uint256[]
     * @param timestamps Parameter of type uint256[]
     * @param deviationThreshold Parameter of type uint256
     * @return taskId Unique identifier for tracking this task
     */
    function _validateOraclePricesAsync(uint256[] calldata priceData, uint256[] calldata timestamps, uint256 deviationThreshold) internal returns (uint256 taskId) {        
        bytes memory encodedParams = abi.encode(priceData, timestamps, deviationThreshold);
        
        return _submitTaskWithCallback(
            "compute_validateOraclePrices", 
            encodedParams,
            address(this)
        );
    }

    /**
     * Call verifyEncryptedAttestation with callback (internal async version)
     * Function verifyEncryptedAttestation from IConfidentialInsuranceSpec
     * The calling contract (address(this)) will receive the callback.
     * @param encryptedAttestation Parameter of type bytes
     * @param proof Parameter of type bytes
     * @param publicInputs Parameter of type uint256[]
     * @return taskId Unique identifier for tracking this task
     */
    function _verifyEncryptedAttestationAsync(bytes calldata encryptedAttestation, bytes calldata proof, uint256[] calldata publicInputs) internal returns (uint256 taskId) {        
        bytes memory encodedParams = abi.encode(encryptedAttestation, proof, publicInputs);
        
        return _submitTaskWithCallback(
            "compute_verifyEncryptedAttestation", 
            encodedParams,
            address(this)
        );
    }

    
    /**
     * Internal function to handle asynchronous task submission with callback
     * @param functionName The name of the function to execute
     * @param encodedParams ABI-encoded parameters
     * @param callbackReceiver Address that will receive the callback
     * @return taskId Unique identifier for tracking this task
     */
    function _submitTaskWithCallback(
        string memory functionName, 
        bytes memory encodedParams,
        address callbackReceiver
    ) internal returns (uint256) {
        // Get the active reservation config ID - this auto-updates with image changes
        // Alternatively, use a fixed configID for execution guarantees
        bytes32 configID = _getImageArchive().getReservationConfigID(reservationID);
        bytes memory callData = abi.encodeWithSignature(
            "requestExecution((bytes32,address,string,bytes))",
            ExecutionRequest({
                configID: configID,
                callbackReceiver: callbackReceiver,
                functionName: functionName,
                encodedParams: encodedParams
            })
        );
        
        (bool success, bytes memory returnData) = _getEigenCompute().call(callData);
        require(success, "EigenCompute call failed");
        
        uint256 taskId = abi.decode(returnData, (uint256));
        return taskId;
    }

    // ================== ABSTRACT CALLBACK METHODS ==================

    /**
     * Abstract callback for aggregateAttestations function completion
     * Override this function in your contract to handle aggregateAttestations results
     * @param taskId The unique identifier for the completed task
     * @param result1 The result returned by  (original type: uint256)
     * @param result2 The result returned by  (original type: bool)
     * @param error Error message if the function failed, empty string if successful
     */
    function _onAggregateAttestations(uint256 taskId, uint256 result1, bool result2, string memory error) internal virtual;

    /**
     * Abstract callback for calculateImpermanentLoss function completion
     * Override this function in your contract to handle calculateImpermanentLoss results
     * @param taskId The unique identifier for the completed task
     * @param result1 The result returned by  (original type: uint256)
     * @param result2 The result returned by  (original type: bool)
     * @param error Error message if the function failed, empty string if successful
     */
    function _onCalculateImpermanentLoss(uint256 taskId, uint256 result1, bool result2, string memory error) internal virtual;

    /**
     * Abstract callback for calculatePayout function completion
     * Override this function in your contract to handle calculatePayout results
     * @param taskId The unique identifier for the completed task
     * @param result The result returned by calculatePayout (original type: uint256)
     * @param error Error message if the function failed, empty string if successful
     */
    function _onCalculatePayout(uint256 taskId, uint256 result, string memory error) internal virtual;

    /**
     * Abstract callback for validateOraclePrices function completion
     * Override this function in your contract to handle validateOraclePrices results
     * @param taskId The unique identifier for the completed task
     * @param result1 The result returned by  (original type: bool)
     * @param result2 The result returned by  (original type: uint256[] memory)
     * @param error Error message if the function failed, empty string if successful
     */
    function _onValidateOraclePrices(uint256 taskId, bool result1, uint256[] memory result2, string memory error) internal virtual;

    /**
     * Abstract callback for verifyEncryptedAttestation function completion
     * Override this function in your contract to handle verifyEncryptedAttestation results
     * @param taskId The unique identifier for the completed task
     * @param result1 The result returned by  (original type: bool)
     * @param result2 The result returned by  (original type: uint256)
     * @param error Error message if the function failed, empty string if successful
     */
    function _onVerifyEncryptedAttestation(uint256 taskId, bool result1, uint256 result2, string memory error) internal virtual;
}
